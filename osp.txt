slip 1

ans 1
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
 pid_t child_pid;
 child_pid = fork();
 if (child_pid == 0) {
 printf("Child process with PID: %d\n", getpid());
 nice(10);
 printf("Child process priority increased\n");
 } else if (child_pid > 0) {
 printf("Parent process with PID: %d\n", getpid());
 wait(NULL);
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2

#include <stdio.h>
int main() {
 int n = 3, memory[3] = {-1}, faults = 0;
 int pages[] = {3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};
 for (int i = 0; i < 15; i++) {
 int p = pages[i], found = 0;
 for (int j = 0; j < n; j++) {
 if (memory[j] == p) {
 found = 1;
 break;}}
 if (!found) {
 faults++;
 memory[faults % n] = p;}}
 printf("Total Page Faults: %d\n", faults);
 return 0;}


===========================================================================================

slip 2

ans 1

#include <stdio.h>
#include <unistd.h>
int main() {
 int child_pid = fork();
 if (child_pid == 0) {
 printf("Child Process ID: %d\n", getpid());
 printf("Hello World\n");
 } else if (child_pid > 0) {
 printf("Parent Process ID: %d\n", getpid());
 printf("Hi\n");
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2

#include <stdio.h>
#include <stdlib.h>

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void sort(int arrival_time[], int cpu_burst[], int io_waiting_time[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arrival_time[j] > arrival_time[j + 1]) {
                swap(&arrival_time[j], &arrival_time[j + 1]);
                swap(&cpu_burst[j], &cpu_burst[j + 1]);
                swap(&io_waiting_time[j], &io_waiting_time[j + 1]);
            }
        }
    }
}

void sjf(int arrival_time[], int cpu_burst[], int io_waiting_time[], int n) {
    sort(arrival_time, cpu_burst, io_waiting_time, n);

    int current_time = 0;
    printf("Gantt Chart:\n");

    for (int i = 0; i < n; i++) {
        printf("| P%d ", i + 1);

        int waiting_time = current_time;
        int turnaround_time = waiting_time + cpu_burst[i];

        current_time += cpu_burst[i] + io_waiting_time[i];

        printf("|");
    }
    
    printf("\n\n");

    printf("Process\tTurnaround Time\tWaiting Time\n");

    for (int i = 0; i < n; i++) {
        int waiting_time = arrival_time[i];
        int turnaround_time = waiting_time + cpu_burst[i] + io_waiting_time[i];
        
        printf("P%d\t%d\t\t%d\n", i + 1, turnaround_time, waiting_time);
    }
}

int main() {
    int n;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    int arrival_time[n];
    int cpu_burst[n];
    int io_waiting_time[n];

    for (int i = 0; i < n; i++) {
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &arrival_time[i]);
        printf("Enter CPU burst for P%d: ", i + 1);
        scanf("%d", &cpu_burst[i]);
        io_waiting_time[i] = 2; // Fixed I/O waiting time
    }

    sjf(arrival_time, cpu_burst, io_waiting_time, n);

    return 0;
}
==============================================================================================

slip 3

ans 1

#include <stdio.h>
#include <unistd.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid == 0) {
 printf("Child process (PID: %d)\n", getpid());
 execl("/bin/ls", "ls", NULL); // Replace with the desired command
 } else if (child_pid > 0) {
 printf("Parent process (PID: %d)\n", getpid());
 wait(NULL); 
 printf("Child process has terminated.\n");
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2

#include <stdio.h>
#include <stdlib.h>

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void sort(int arrival_time[], int cpu_burst[], int io_waiting_time[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arrival_time[j] > arrival_time[j + 1]) {
                swap(&arrival_time[j], &arrival_time[j + 1]);
                swap(&cpu_burst[j], &cpu_burst[j + 1]);
                swap(&io_waiting_time[j], &io_waiting_time[j + 1]);
            }
        }
    }
}

void fcfs(int arrival_time[], int cpu_burst[], int io_waiting_time[], int n) {
    sort(arrival_time, cpu_burst, io_waiting_time, n);

    int current_time = 0;
    printf("Gantt Chart:\n");

    for (int i = 0; i < n; i++) {
        printf("| P%d ", i + 1);

        int waiting_time = current_time;
        int turnaround_time = waiting_time + cpu_burst[i];

        current_time += cpu_burst[i] + io_waiting_time[i];

        printf("|");
    }
    
    printf("\n\n");

    float total_turnaround_time = 0;
    float total_waiting_time = 0;

    printf("Process\tTurnaround Time\tWaiting Time\n");

    for (int i = 0; i < n; i++) {
        int waiting_time = arrival_time[i];
        int turnaround_time = waiting_time + cpu_burst[i] + io_waiting_time[i];
        
        printf("P%d\t%d\t\t%d\n", i + 1, turnaround_time, waiting_time);

        total_turnaround_time += turnaround_time;
        total_waiting_time += waiting_time;
    }

    printf("\nAverage Turnaround Time: %.2f\n", total_turnaround_time / n);
    printf("Average Waiting Time: %.2f\n", total_waiting_time / n);
}

int main() {
    int n;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    int arrival_time[n];
    int cpu_burst[n];
    int io_waiting_time[n];

    for (int i = 0; i < n; i++) {
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &arrival_time[i]);
        printf("Enter CPU burst for P%d: ", i + 1);
        scanf("%d", &cpu_burst[i]);
        io_waiting_time[i] = 2; // Fixed I/O waiting time
    }

    fcfs(arrival_time, cpu_burst, io_waiting_time, n);

    return 0;
}

================================================================================
slip 4

ans 1

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid == 0) {
 printf("Child process (PID: %d) is running, and its parent (PPID: %d) has terminated.\n", getpid(), getppid());
 sleep(5); 
 printf("Child process (PID: %d) has completed.\n", getpid());
 } else if (child_pid > 0) {
 printf("Parent process (PID: %d) is running and will terminate shortly.\n", getpid());
 sleep(2); 
 printf("Parent process (PID: %d) has terminated.\n", getpid());
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2
#include <stdio.h>
#include <stdlib.h>

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void sort_by_priority(int process_id[], int arrival_time[], int cpu_burst[], int priority[], int io_waiting_time[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (priority[j] > priority[j + 1]) {
                swap(&process_id[j], &process_id[j + 1]);
                swap(&arrival_time[j], &arrival_time[j + 1]);
                swap(&cpu_burst[j], &cpu_burst[j + 1]);
                swap(&priority[j], &priority[j + 1]);
                swap(&io_waiting_time[j], &io_waiting_time[j + 1]);
            }
        }
    }
}

void priority_scheduling(int process_id[], int arrival_time[], int cpu_burst[], int priority[], int io_waiting_time[], int n) {
    sort_by_priority(process_id, arrival_time, cpu_burst, priority, io_waiting_time, n);

    int current_time = 0;
    printf("Gantt Chart:\n");

    for (int i = 0; i < n; i++) {
        printf("| P%d ", process_id[i]);

        int waiting_time = current_time;
        int turnaround_time = waiting_time + cpu_burst[i];

        current_time += cpu_burst[i] + io_waiting_time[i];

        printf("|");
    }

    printf("\n\n");

    float total_turnaround_time = 0;
    float total_waiting_time = 0;

    printf("Process\tTurnaround Time\tWaiting Time\n");

    for (int i = 0; i < n; i++) {
        int waiting_time = arrival_time[i];
        int turnaround_time = waiting_time + cpu_burst[i] + io_waiting_time[i];

        printf("P%d\t%d\t\t%d\n", process_id[i], turnaround_time, waiting_time);

        total_turnaround_time += turnaround_time;
        total_waiting_time += waiting_time;
    }

    printf("\nAverage Turnaround Time: %.2f\n", total_turnaround_time / n);
    printf("Average Waiting Time: %.2f\n", total_waiting_time / n);
}

int main() {
    int n;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    int process_id[n];
    int arrival_time[n];
    int cpu_burst[n];
    int priority[n];
    int io_waiting_time[n];

    for (int i = 0; i < n; i++) {
        process_id[i] = i + 1;
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &arrival_time[i]);
        printf("Enter CPU burst for P%d: ", i + 1);
        scanf("%d", &cpu_burst[i]);
        printf("Enter priority for P%d: ", i + 1);
        scanf("%d", &priority[i]);
        io_waiting_time[i] = 2; // Fixed I/O waiting time
    }

    priority_scheduling(process_id, arrival_time, cpu_burst, priority, io_waiting_time, n);

    return 0;
}


===================================================================================================

slip 5

ans 1

#include <unistd.h>
int main() {
 int child_pid = fork();
 if (child_pid == 0) {
 printf("Child process with PID: %d\n", getpid());
 nice(10);
 printf("Child process priority increased\n");
 } else if (child_pid > 0) {
 printf("Parent process with PID: %d\n", getpid());
 wait(NULL);
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2

#include <stdio.h>
int main() {
 int n = 3, referenceString[] = {3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};
 int memory[n], faults = 0, i = 0;
 for (int j = 0; j < n; j++) memory[j] = -1;
 printf("Page Scheduling using FIFO:\n");
 for (int r = 0; r < 15; r++) {
 int page = referenceString[r], found = 0;
 for (int j = 0; j < n; j++) {
 if (memory[j] == page) {
 found = 1;
 break;}}
 if (!found) {
 faults++;
 if (memory[i % n] != -1) {
 printf("Page %d replaced by Page %d\n", memory[i % n], page);}
 memory[i % n] = page;
 i++;
 printf("Page %d -> Page Fault\nMemory: ", page);
 for (int j = 0; j < n; j++) {
 printf("%d ", memory[j]);}
 printf("\n");}}
 printf("Total Page Faults: %d\n", faults);
 return 0;}


==================================================================================

slip 6

ans 1

#include <stdio.h>
#include <time.h>
int main() {
 clock_t start_time, end_time;
 double execution_time;
 start_time = clock();
 for (int i = 0; i < 1000000; i++) {
 int result = i * i;}
 end_time = clock();
 execution_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;
 printf("Execution time: %f seconds\n", execution_time);
 return 0;}


ans 2
#include<stdio.h>
int n=15,nf;//n is length of reference string
int in[20]={3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&nf);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<nf; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<nf; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<nf; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<nf; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<nf-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}

======================================================================================
slip 7


ans 1

#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid < 0) {
 perror("Fork failed");
 exit(1);}
 if (child_pid == 0) {
 execl("/bin/ls", "ls", NULL);
 perror("Execl failed");
 exit(1);
 } else {
 printf("Parent process is going to sleep for 3 seconds...\n");
 sleep(3);
 wait(NULL); 
 printf("Parent process has woken up.\n");}
 return 0;
}
ans 2

#include <stdio.h>
#include <stdlib.h>

int main() {
    int AT[10], BT[10], WT[10], TT[10], n;
    int burst = 0, cmpl_T;
    float Avg_WT, Avg_TT, Total = 0;
    time_t t;

    printf("Enter number of processes\n");
    scanf("%d", &n);

    printf("Enter Arrival time of the processes\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &AT[i]);
    }

    printf("Enter the Burst time of first process\n");
    scanf("%d", &BT[0]);

    /* Initializes random number generator */
    srand((unsigned)time(&t));

    /* For Burst time generate n random numbers from 0 to 10 */
    for (int i = 1; i < n; i++)
        BT[i] = rand() % 10;

    printf("Burst Times generated using random function are...\n");
    for (int i = 0; i < n; i++)
        printf("%d\n", BT[i]);

    // Logic for calculating Waiting time
    for (int i = 0; i < n; i++) {
        if (i == 0)
            WT[i] = AT[i];
        else
            WT[i] = burst - AT[i];
        burst += BT[i];
        Total += WT[i];
    }
    Avg_WT = Total / n;

    // Logic for calculating Turnaround time
    cmpl_T = 0;
    Total = 0;

    printf("\nGantt Chart:\n");
    printf(" ");
    for (int i = 0; i < n * 8; i++) {
        printf("-");
    }
    printf("\n|");
    for (int i = 0; i < n; i++) {
        int len = (i == 0) ? AT[i] : BT[i];
        for (int j = 0; j < len; j++) {
            printf(" ");
        }
        printf("P%d", i + 1);
        for (int j = 0; j < BT[i]; j++) {
            printf(" ");
        }
        printf("|");
    }
    printf("\n ");
    for (int i = 0; i < n * 8; i++) {
        printf("-");
    }
    printf("\n");

    // Logic for calculating Turnaround time
    cmpl_T = 0;
    Total = 0;

    printf("0\t");
    for (int i = 0; i < n; i++) {
        cmpl_T += BT[i];
        TT[i] = cmpl_T - AT[i];
        Total += TT[i];
        printf("%d\t", cmpl_T);
    }

    Avg_TT = Total / n;

    // Printing of outputs
    printf("\n\nProcess, Waiting_time, Turnaround_time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t\t%d\t\t%d\n", i + 1, WT[i], TT[i]);
    }
    printf("\nAverage waiting time is : %f\n", Avg_WT);
    printf("Average turnaround time is : %f\n", Avg_TT);

    return 0;
}


=======================================================================================


slip 8

ans 1
#include <stdio.h>
int main() {
 int n, m;
 printf("Enter processes and resources: ");
 scanf("%d %d", &n, &m);
 int alloc[n][m], max[n][m], need[n][m];
 printf("Enter allocation and max matrices:\n");
 for (int i = 0; i < n; i++) {
 for (int j = 0; j < m; j++) {
 scanf("%d %d", &alloc[i][j], &max[i][j]);
 need[i][j] = max[i][j] - alloc[i][j];}}
 printf("Need matrix:\n");
 for (int i = 0; i < n; i++) {
 for (int j = 0; j < m; j++) {
 printf("%d ", need[i][j]);}
 printf("\n");}
 return 0;}

ans2
#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
} 

====================================================================================
slip 9

ans 1
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid < 0) {
 perror("Fork failed");
 exit(1);}
 if (child_pid == 0) {
 execl("/bin/ls", "ls", NULL);
 perror("Execl failed");
 exit(1);
 } else {
 printf("Parent process is going to sleep for 3 seconds...\n");
 sleep(3);
 wait(NULL); 
 printf("Parent process has woken up.\n");}
 return 0;
}

ans 2
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_PROCESSES 10

void roundRobinScheduling(int arrival_time[], int burst_time[], int n, int time_quantum) {
    int remaining_burst[MAX_PROCESSES];
    int turnaround_time[MAX_PROCESSES];
    int waiting_time[MAX_PROCESSES];

    srand(time(NULL));

    for (int i = 0; i < n; i++) {
        remaining_burst[i] = burst_time[i];
        turnaround_time[i] = 0;
        waiting_time[i] = 0;
    }

    int currentTime = 0;
    int remainingProcesses = n;

    while (remainingProcesses > 0) {
        for (int i = 0; i < n; i++) {
            if (remaining_burst[i] > 0) {
                int executeTime = (remaining_burst[i] < time_quantum) ? remaining_burst[i] : time_quantum;

                remaining_burst[i] -= executeTime;
                currentTime += executeTime;

                // Print Gantt Chart
                printf("| P%d ", i + 1);

                if (remaining_burst[i] == 0) {
                    remainingProcesses--;

                    // Generate the next CPU burst randomly (between 1 and 10)
                    int nextBurst = rand() % 10 + 1;
                    burst_time[i] = nextBurst;
                    
                    turnaround_time[i] = currentTime - arrival_time[i];
                    waiting_time[i] = turnaround_time[i] - burst_time[i];
                }
            }
        }
    }

    printf("|\n");

    // Print Turnaround Time and Waiting Time
    printf("\n\nProcess\tTurnaround Time\tWaiting Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t\t%d\n", i + 1, turnaround_time[i], waiting_time[i]);
    }

    // Calculate and print average times
    float avg_turnaround_time = 0, avg_waiting_time = 0;
    for (int i = 0; i < n; i++) {
        avg_turnaround_time += turnaround_time[i];
        avg_waiting_time += waiting_time[i];
    }

    avg_turnaround_time /= n;
    avg_waiting_time /= n;

    printf("\nAverage Turnaround Time: %.2f\n", avg_turnaround_time);
    printf("Average Waiting Time: %.2f\n", avg_waiting_time);
}

int main() {
    int n, time_quantum;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    if (n <= 0 || n > MAX_PROCESSES) {
        printf("Invalid number of processes. Exiting...\n");
        return 1;
    }

    int arrival_time[MAX_PROCESSES];
    int burst_time[MAX_PROCESSES];

    // Input arrival time and burst time for each process
    for (int i = 0; i < n; i++) {
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &arrival_time[i]);

        printf("Enter burst time for P%d: ", i + 1);
        scanf("%d", &burst_time[i]);
    }

    // Input time quantum
    printf("Enter the time quantum: ");
    scanf("%d", &time_quantum);

    // Print Gantt Chart header
    printf("\nGantt Chart:\n|");

    // Run Round Robin Scheduling
    roundRobinScheduling(arrival_time, burst_time, n, time_quantum);

    return 0;
}

=====================================================================================

slip 10

ans 1
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t child_pid = fork();

    if (child_pid < 0) {
        // Fork failed
        perror("Fork failed");
        return 1;
    }

    if (child_pid > 0) {
        // Parent process
        printf("Parent process (PID: %d) sleeping for 5 seconds\n", getpid());
        sleep(5);
        printf("Parent process exiting\n");
    } else {
        // Child process
        printf("Child process (PID: %d) sleeping for 2 seconds\n", getpid());
        sleep(2);
        printf("Child process (PID: %d) exiting\n", getpid());
    }

    // Both parent and child continue from here
    printf("Process (PID: %d) continuing after fork\n", getpid());

    return 0;
}


ans 2

#include <stdio.h>
#include <stdlib.h>

int main() {
    int AT[10], BT[10], WT[10], TT[10], n;
    int burst = 0, cmpl_T;
    float Avg_WT, Avg_TT, Total = 0;
    time_t t;

    printf("Enter number of processes\n");
    scanf("%d", &n);

    printf("Enter Arrival time of the processes\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &AT[i]);
    }

    printf("Enter the Burst time of first process\n");
    scanf("%d", &BT[0]);

    /* Initializes random number generator */
    srand((unsigned)time(&t));

    /* For Burst time generate n random numbers from 0 to 10 */
    for (int i = 1; i < n; i++)
        BT[i] = rand() % 10;

    printf("Burst Times generated using random function are...\n");
    for (int i = 0; i < n; i++)
        printf("%d\n", BT[i]);

    // Logic for calculating Waiting time
    for (int i = 0; i < n; i++) {
        if (i == 0)
            WT[i] = AT[i];
        else
            WT[i] = burst - AT[i];
        burst += BT[i];
        Total += WT[i];
    }
    Avg_WT = Total / n;

    // Logic for calculating Turnaround time
    cmpl_T = 0;
    Total = 0;

    printf("\nGantt Chart:\n");
    printf(" ");
    for (int i = 0; i < n * 8; i++) {
        printf("-");
    }
    printf("\n|");
    for (int i = 0; i < n; i++) {
        int len = (i == 0) ? AT[i] : BT[i];
        for (int j = 0; j < len; j++) {
            printf(" ");
        }
        printf("P%d", i + 1);
        for (int j = 0; j < BT[i]; j++) {
            printf(" ");
        }
        printf("|");
    }
    printf("\n ");
    for (int i = 0; i < n * 8; i++) {
        printf("-");
    }
    printf("\n");

    // Logic for calculating Turnaround time
    cmpl_T = 0;
    Total = 0;

    printf("0\t");
    for (int i = 0; i < n; i++) {
        cmpl_T += BT[i];
        TT[i] = cmpl_T - AT[i];
        Total += TT[i];
        printf("%d\t", cmpl_T);
    }

    Avg_TT = Total / n;

    // Printing of outputs
    printf("\n\nProcess, Waiting_time, Turnaround_time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t\t%d\t\t%d\n", i + 1, WT[i], TT[i]);
    }
    printf("\nAverage waiting time is : %f\n", Avg_WT);
    printf("Average turnaround time is : %f\n", Avg_TT);

    return 0;
}

======================================================================

slip 11

ans 1


#include <stdio.h>
#include <unistd.h>
int main() {
 int child_pid = fork();
 if (child_pid == 0) {
 printf("Child Process ID: %d\n", getpid());
 printf("Hello World\n");
 } else if (child_pid > 0) {
 printf("Parent Process ID: %d\n", getpid());
 printf("Hi\n");
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2

#include<stdio.h>
int n=12,nf;//n is length of reference string
int in[20]={0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&nf);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<nf; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<nf; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<nf; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<nf; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<nf-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}
=====================================================================


slip 12

ans 1
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t child_pid = fork();

    if (child_pid < 0) {
        // Fork failed
        perror("Fork failed");
        return 1;
    }

    if (child_pid > 0) {
        // Parent process
        printf("Parent process (PID: %d) sleeping for 5 seconds\n", getpid());
        sleep(5);
        printf("Parent process exiting\n");
    } else {
        // Child process
        printf("Child process (PID: %d) sleeping for 2 seconds\n", getpid());
        sleep(2);
        printf("Child process (PID: %d) exiting\n", getpid());
    }

    // Both parent and child continue from here
    printf("Process (PID: %d) continuing after fork\n", getpid());

    return 0;
}

ans2

#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}

============================================================================

slip 13

ans 1
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
 pid_t child_pid;
 child_pid = fork();
 if (child_pid == 0) {
 printf("Child process with PID: %d\n", getpid());
 nice(10);
 printf("Child process priority increased\n");
 } else if (child_pid > 0) {
 printf("Parent process with PID: %d\n", getpid());
 wait(NULL);
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans2

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int AT[20]={1,3,6,7,9},BT[20]={7,3,2,10,8};
char ch ='-';
int CT[20],TT[20],p[20]={1,2,3,4,5},wt[20],tat[20],temp_BT[20];
int flag[20], first_time=1,finish = 0, shortest_job_pos;
int i,j,x,n=5,pos,temp,cmpl_T;
float Total_TT=0,Total_WT=0;


//---------------------------------------------------------
void sort_CT()
{
int i,j,temp;
for(i=0;i<n;i++)
    {
	for(j=i+1;j<n;j++)
	{
	    if(CT[j] < CT[i])
	     {
		temp=CT[i];
		CT[i]=CT[j];
		CT[j]=temp;
	     }
	}
}
}
//----------------------------------------------------------------
int find_min(int a[])
 {
    int i, minimum, minimum_pos;
    minimum= a[0];
    //first_time = 1;
    for ( i=0 ;i<n ; i++)
    {
     if (a[i] < minimum  && flag[i] != 1)
	{
	minimum = a[i];
	minimum_pos= i;
	}
    }
    return minimum_pos;
}
//-----------------------------------------------------------------
int find_min_BT(int a[])
 {
    int i,j,minimum, minimum_pos;
    for(i=0;i<n ;i++)
     if ( a[i] !=0)
     {
	  minimum= a[i];
	  break;
     }
    for ( j=i+1;j<n; j++)
     if (a[j] < minimum  && flag[j] != 1)
	minimum = a[j];
    flag[i]= 1;
    return i;
}

int SJF(int bt[])
{
    int min_pos,k;
    if(first_time == 1)
    {
       shortest_job_pos = find_min(AT);
       x=cmpl_T=AT[shortest_job_pos];
       printf("======SJF Non Preemptive====\n");
       printf("\n Gantt Chart    \n");
       printf(" ");
       for(i=0;i<= (n-1)*8;i++)
	printf("%c",ch);

       printf("\n");

       for(i=0;i<n+1;i++)
	  printf("|      ");

       printf("\n");
       printf("|" );
     }
    for(i=0;i<n;i++)
    {
      if( first_time ==1 && flag[shortest_job_pos] == 0)// first job
       {
		cmpl_T += BT[shortest_job_pos];
		CT[shortest_job_pos]=cmpl_T;
		TT[shortest_job_pos]=cmpl_T-AT[shortest_job_pos];
		Total_TT+=TT[i];
		//printf("%d\t",cmpl_T);
		flag[shortest_job_pos]= 1;
		first_time=0;
       }
       else //if(first_time == 0),now it is not first job,find the shortest job
       {
	  for ( i= 0;i<=n; i++)
	  {
	   if( AT[i] <= cmpl_T && flag[i]==0)
	       temp_BT[i]= BT[i];
	  }
	    for( i=0;i<=cmpl_T ; i++)
	    {
		shortest_job_pos = find_min_BT(temp_BT);
		cmpl_T += temp_BT[shortest_job_pos];
		CT[shortest_job_pos]=cmpl_T;
		TT[shortest_job_pos]=cmpl_T-AT[shortest_job_pos];
		wt[shortest_job_pos]=TT[shortest_job_pos]-temp_BT[shortest_job_pos];
		Total_TT+=TT[shortest_job_pos];
		break;
	   }      // end of for
	 }// end of else if
	 for(k=0;k<n;k++)
	    temp_BT[k]=0;
	 printf("  P%d  |",p[shortest_job_pos]);
	 finish++;
	 if (finish == n)
	    return 0;
       } //end of for
//}//end of while
return k;
}
//----------------------------------------------------------------------
 int main()
{
    int k,min,pos,p_id,CT_1[20];
    float avg_wt,avg_tat;
    time_t t;

    
    for(i=0;i<n;i++)
    flag[i] = 0;
    /*printf("Enter number of process:");
    scanf("%d",&n);
      */
 /* printf("Enter Arrival time of the processess\n");
    printf("AT\n");
    for(i=0;i<n;i++)
    {
	scanf("%d",&AT[i]);
    }*/
//    printf("Enter the Burst time of first process\n");
  //  scanf("%d",&BT[0]);

  /*printf("Enter the Burst time of the process\n");
   for(i=0;i<n;i++)
    {
	scanf("%d",&BT[i]);
    }*/
   /* Intializes random number generator */
    // srand((unsigned) time(&t));

   /* For Burst time generate n random numbers from 0 to 10 */
  /*  for( i = 1 ; i < n ; i++ )
	 BT[i]= rand() % 10;
    printf("Burst Times generated using random funtion are...\n");
    for (i=0;i<n;i++)
       printf("%d\n",BT[i]);
    */

   //sorting of burst times
    for(i=0;i<n;i++)
    {
	pos=i;
	for(j=i+1;j<n;j++)
	{
	    if(BT[j]<BT[pos])
		pos=j;
	}

	temp=BT[i];
	BT[i]=BT[pos];
	BT[pos]=temp;

	temp=p[i];
	p[i]=p[pos];
	p[pos]=temp;

	temp=AT[i];
	AT[i]=AT[pos];
	AT[pos]=temp;

    }

    cmpl_T=0;
    SJF(BT);
    printf("\n");
    printf(" ");
    for(i=0;i<= (n-1)*8;i++)
    {
	   printf("%c",ch);
    }
    printf("\n%d   ",x);
    for(i=0;i<n;i++)
      CT_1[i]= CT[i];
    sort_CT();
    for (i=0;i<n;i++)
    {
	  printf("   %d  ",CT[i]);
    }
    printf("\n\n\nProcess\tArrival Time\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time\t\n");
    for(i=0;i<n;i++)
    {
	printf(" P%d\t  %d\t\t%d\t\t    %d\t\t  %d\t\t%d\n",i+1,AT[i],BT[i],CT_1[i],TT[i],wt[i]);
    }
    for(i=0;i<n;i++)
       Total_WT+= wt[i];
    avg_wt=(float)Total_WT/n;
    printf("\nAverage Waiting Time=%.1f",avg_wt);

    for(i=0;i<n;i++)
       Total_TT+= TT[i];
    avg_tat=(float)Total_TT/n;
    printf("\nAverage Turnaround Time=%.1f",avg_tat);
   return 0;
}

======================================================================



slip 14

ans 1
#include <stdio.h>
#include <time.h>
int main() {
 clock_t start_time, end_time;
 double execution_time;
 start_time = clock();
 for (int i = 0; i < 1000000; i++) {
 int result = i * i;}
 end_time = clock();
 execution_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;
 printf("Execution time: %f seconds\n", execution_time);
 return 0;}


ans 2


#include<stdio.h>
int n=12,nf;//n is length of reference string
int in[20]={0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1};//Reference String
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;

void getData()
{
	printf("\nEnter no of frames:");
	scanf("%d",&nf);
}

void initialize()
{
	pgfaultcnt=0;
	for(i=0; i<nf; i++)
		p[i]=9999;
}

int isHit(int data)
{
	hit=0;
	for(j=0; j<nf; j++)
	{
		if(p[j]==data)
		{
			hit=1;
			break;
		}
	}
	return hit;
}

int getHitIndex(int data)
{
	int hitind;
	for(k=0; k<nf; k++)
	{
		if(p[k]==data)
		{
			hitind=k;
			break;
		}
	}
	return hitind;
}

void dispPages()
{
	for (k=0; k<nf; k++)
	{
		if(p[k]!=9999)
			printf(" %d",p[k]);
	}
}

void dispPgFaultCnt()
{
	printf("\nTotal no of page faults:%d",pgfaultcnt);
}

void fifo()
{
	initialize();
	for(i=0; i<n; i++)
	{
		printf("\nFor %d :",in[i]);
		
		if(isHit(in[i])==0)
		{
			for(k=0; k<nf-1; k++)
			p[k]=p[k+1];

		p[k]=in[i];
		pgfaultcnt++;
		dispPages();
	}
	else
		printf("No page fault");
	}
	dispPgFaultCnt();
}


int main()
{
        getData();
        fifo();
}
===================================================================
slip 15

ans 1

#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid < 0) {
 perror("Fork failed");
 exit(1);}
 if (child_pid == 0) {
 execl("/bin/ls", "ls", NULL);
 perror("Execl failed");
 exit(1);
 } else {
 printf("Parent process is going to sleep for 3 seconds...\n");
 sleep(3);
 wait(NULL); 
 printf("Parent process has woken up.\n");}
 return 0;
}

ans 2

#include <stdio.h>
#include <stdlib.h>
int findLRU(int frames[], int n, int page, int current) {
 int index = -1;
 int farthest = current;
 for (int i = 0; i < n; i++) {
 int j;
 for (j = current - 1; j >= 0; j--) {
 if (frames[i] == page) {
 break;}
 if (frames[i] == -1 || frames[i] == frames[j]) {
 if (j < farthest) {
 farthest = j;
 index = i;}
 break;}}}
 return index;}
int main() {
 int n = 3; 
 int referenceString[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
 int referenceStringLength = sizeof(referenceString) / sizeof(referenceString[0]);
 int frames[n];
 int pageFaults = 0;
 for (int i = 0; i < n; i++) {
 frames[i] = -1;}
 printf("Page Scheduling using LRU:\n");
 for (int i = 0; i < referenceStringLength; i++) {
 int page = referenceString[i];
 int found = 0;
 for (int j = 0; j < n; j++) {
 if (frames[j] == page) {
 found = 1;
 break;}}
 if (!found) {
 int replaceIndex = findLRU(frames, n, page, i);
 frames[replaceIndex] = page;
 pageFaults++;
 printf("Page %d -> Page Fault\n", page);}}
 printf("Total Page Faults: %d\n", pageFaults);
 return 0;}


==================================================================================
slip 16

ans 1

#include <stdio.h>
#include <time.h>
int main() {
 clock_t start_time, end_time;
 double execution_time;
 start_time = clock();
 for (int i = 0; i < 1000000; i++) {
 int result = i * i;}
 end_time = clock();
 execution_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;
 printf("Execution time: %f seconds\n", execution_time);
 return 0;}

ans 2

#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}

=====================================================================================

slip 17

ans 1

#include <stdio.h>
int main() {
 int allocated[3][3] = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}};
 int max_demand[3][3] = {{4, 4, 4}, {5, 5, 5}, {6, 6, 6}};
 int available[3] = {0};
 for (int i = 0; i < 3; i++) {
 for (int j = 0; j < 3; j++) {
 available[j] += max_demand[i][j] - allocated[i][j];}}
 printf("Minimum resources needed to avoid deadlock: ");
 for (int i = 0; i < 3; i++) {
 printf("%d ", available[i]);}
 printf("\n");
 return 0;}

ans 2



#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}
========================================================================================

slip 18

ans 1
#include <stdio.h>
int main() {
 int n, m;
 printf("Enter processes and resources: ");
 scanf("%d %d", &n, &m);
 int alloc[n][m], max[n][m], need[n][m];
 printf("Enter allocation and max matrices:\n");
 for (int i = 0; i < n; i++) {
 for (int j = 0; j < m; j++) {
 scanf("%d %d", &alloc[i][j], &max[i][j]);
 need[i][j] = max[i][j] - alloc[i][j];}}
 printf("Need matrix:\n");
 for (int i = 0; i < n; i++) {
 for (int j = 0; j < m; j++) {
 printf("%d ", need[i][j]);}
 printf("\n");}
 return 0;}

ans 2

#include<stdio.h>
int n=16,nf;//n is length of reference string 
int in[20]={12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8};//reference string 
int p[50];
int hit=0;
int i,j,k;
int pgfaultcnt=0;
 
void getData()
{
    printf("\nEnter no of frames:");
    scanf("%d",&nf);
}
 
void initialize()
{
    pgfaultcnt=0;
    for(i=0; i<nf; i++)
        p[i]=9999;
}
 
int isHit(int data)
{
    hit=0;
    for(j=0; j<nf; j++)
    {
        if(p[j]==data)
        {
            hit=1;
            break;
        }
     }
     return hit;
}
 
int getHitIndex(int data)
{
    int hitind;
    for(k=0; k<nf; k++)
    {
        if(p[k]==data)
        {
            hitind=k;
            break;
        }
    }
    return hitind;
}
 
void dispPages()
{
    for (k=0; k<nf; k++)
    {
        if(p[k]!=9999)
            printf(" %d",p[k]);
    }
 }
 
void dispPgFaultCnt()
{
    printf("\nTotal no of page faults:%d",pgfaultcnt);
}
 
 
 void optimal()
{
    initialize();
    int near[50];
    for(i=0; i<n; i++)
    {
         printf("\nFor %d :",in[i]);
 
        if(isHit(in[i])==0)
        {
            for(j=0; j<nf; j++)
            {
                int pg=p[j];
                int found=0;
                for(k=i; k<n; k++)
                {
                    if(pg==in[k])
                    {
                        near[j]=k;
                        found=1;
                        break;
                    }
                    else
                        found=0;
                }
                if(!found)
                    near[j]=9999;
            }
            int max=-9999;
            int repindex;
            for(j=0; j<nf; j++)
            {
                if(near[j]>max)
                {
                    max=near[j];
                    repindex=j;
                }
            }
            p[repindex]=in[i];
            pgfaultcnt++;
 
            dispPages();
        }
        else
            printf("No page fault");
    }
    dispPgFaultCnt();
}
 
 
int main()
{
            getData();
            optimal();
}

====================================================================================

slip 19

ans 1

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid < 0) {
 perror("Fork failed");
 exit(1);}
 if (child_pid == 0) {
 execl("/bin/ls", "ls", NULL);
 perror("Execl failed");
 exit(1);
 } else {
 printf("Parent process is going to sleep for 3 seconds...\n");
 sleep(3);
 wait(NULL); 
 printf("Parent process has woken up.\n");}
 return 0;
}

ans 2

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid == 0) {
 printf("Child process (PID: %d) is running, and its parent (PPID: %d) has terminated.\n", getpid(), getppid());
 sleep(5); 
 printf("Child process (PID: %d) has completed.\n", getpid());
 } else if (child_pid > 0) {
 printf("Parent process (PID: %d) is running and will terminate shortly.\n", getpid());
 sleep(2); 
 printf("Parent process (PID: %d) has terminated.\n", getpid());
 } else {
 perror("Fork failed");
 return 1;}
 return 0;}

ans 2
#include <stdio.h>
#include <stdlib.h>

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void sort_by_priority(int process_id[], int arrival_time[], int cpu_burst[], int priority[], int io_waiting_time[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (priority[j] > priority[j + 1]) {
                swap(&process_id[j], &process_id[j + 1]);
                swap(&arrival_time[j], &arrival_time[j + 1]);
                swap(&cpu_burst[j], &cpu_burst[j + 1]);
                swap(&priority[j], &priority[j + 1]);
                swap(&io_waiting_time[j], &io_waiting_time[j + 1]);
            }
        }
    }
}

void priority_scheduling(int process_id[], int arrival_time[], int cpu_burst[], int priority[], int io_waiting_time[], int n) {
    sort_by_priority(process_id, arrival_time, cpu_burst, priority, io_waiting_time, n);

    int current_time = 0;
    printf("Gantt Chart:\n");

    for (int i = 0; i < n; i++) {
        printf("| P%d ", process_id[i]);

        int waiting_time = current_time;
        int turnaround_time = waiting_time + cpu_burst[i];

        current_time += cpu_burst[i] + io_waiting_time[i];

        printf("|");
    }

    printf("\n\n");

    float total_turnaround_time = 0;
    float total_waiting_time = 0;

    printf("Process\tTurnaround Time\tWaiting Time\n");

    for (int i = 0; i < n; i++) {
        int waiting_time = arrival_time[i];
        int turnaround_time = waiting_time + cpu_burst[i] + io_waiting_time[i];

        printf("P%d\t%d\t\t%d\n", process_id[i], turnaround_time, waiting_time);

        total_turnaround_time += turnaround_time;
        total_waiting_time += waiting_time;
    }

    printf("\nAverage Turnaround Time: %.2f\n", total_turnaround_time / n);
    printf("Average Waiting Time: %.2f\n", total_waiting_time / n);
}

int main() {
    int n;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    int process_id[n];
    int arrival_time[n];
    int cpu_burst[n];
    int priority[n];
    int io_waiting_time[n];

    for (int i = 0; i < n; i++) {
        process_id[i] = i + 1;
        printf("Enter arrival time for P%d: ", i + 1);
        scanf("%d", &arrival_time[i]);
        printf("Enter CPU burst for P%d: ", i + 1);
        scanf("%d", &cpu_burst[i]);
        printf("Enter priority for P%d: ", i + 1);
        scanf("%d", &priority[i]);
        io_waiting_time[i] = 2; // Fixed I/O waiting time
    }

    priority_scheduling(process_id, arrival_time, cpu_burst, priority, io_waiting_time, n);

    return 0;
}


==============================================================================================

slip 20

ans 1

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
 pid_t child_pid = fork();
 if (child_pid < 0) {
 perror("Fork failed");
 exit(1);}
 if (child_pid == 0) {
 execl("/bin/ls", "ls", NULL);
 perror("Execl failed");
 exit(1);
 } else {
 printf("Parent process is going to sleep for 3 seconds...\n");
 sleep(3);
 wait(NULL); 
 printf("Parent process has woken up.\n");}
 return 0;}

ans 2

#include <stdio.h>
#include <stdlib.h>
int findLRU(int frames[], int n, int page, int current) {
 int index = -1;
 int farthest = current;
 for (int i = 0; i < n; i++) {
 int j;
 for (j = current - 1; j >= 0; j--) {
 if (frames[i] == page) {
 break;}
 if (frames[i] == -1 || frames[i] == frames[j]) {
 if (j < farthest) {
 farthest = j;
 index = i;}
 break;}}}
 return index;}
int main() {
 int n = 3; 
 int referenceString[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
 int referenceStringLength = sizeof(referenceString) / sizeof(referenceString[0]);
 int frames[n];
 int pageFaults = 0;
 for (int i = 0; i < n; i++) {
 frames[i] = -1;}
 printf("Page Scheduling using LRU:\n");
 for (int i = 0; i < referenceStringLength; i++) {
 int page = referenceString[i];
 int found = 0;
 for (int j = 0; j < n; j++) {
 if (frames[j] == page) {
 found = 1;
 break;}}
 if (!found) {
 int replaceIndex = findLRU(frames, n, page, i);
 frames[replaceIndex] = page;
 pageFaults++;
 printf("Page %d -> Page Fault\n", page);}}
 printf("Total Page Faults: %d\n", pageFaults);
 return 0;}